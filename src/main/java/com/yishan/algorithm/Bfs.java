package com.yishan.algorithm;import com.yishan.stucture.TreeNode;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;public class Bfs {//    public static void main(String args[]) {//        Bfs bfs = new Bfs();//        TreeNode root = bfs.buildBinaryTree();//        System.out.println(bfs.largestValues(root));//////        Bfs bfsTwo = new Bfs();//        TreeNode node = bfsTwo.justBinaryTree();//        System.out.println(bfsTwo.hasPathSum(node, 0));//    }//    private TreeNode buildBinaryTree() {//        TreeNode root = new TreeNode(1);//        root.left = new TreeNode(3);//        root.right = new TreeNode(2);//        root.left.left = new TreeNode(5);//        root.left.right = new TreeNode(3);//        root.right.right = new TreeNode(9);//        return root;//    }////    private TreeNode justBinaryTree() {//        TreeNode node = new TreeNode(1);//        node.left = new TreeNode(5);//        node.right = new TreeNode(9);//        node.left.left = new TreeNode(10);//        node.left.right = new TreeNode(8);//        node.left.right.right = new TreeNode(9);//        node.right.right = new TreeNode(7);//        node.right.right.right = new TreeNode(10);//        return node;//    }    private List<TreeNode> largestValues(TreeNode root) {        if (root == null) {            return new ArrayList<>();        }        List<TreeNode> result = new ArrayList<>();        Queue<TreeNode> queue = new LinkedList<>();        queue.offer(root);        while (!queue.isEmpty()) {            int s = queue.size();            TreeNode temp = queue.peek();            for (int i = 0; i < s; i++) {                TreeNode treeNode = queue.poll();                if (treeNode.val >= temp.val) {                    temp = treeNode;                }                if (treeNode.right != null) {                    queue.offer(treeNode.right);                }                if (treeNode.left != null) {                    queue.offer(treeNode.left);                }            }            result.add(temp);        }        return result;    }    public boolean hasPathSum(TreeNode node, int sum2) {        if (node == null)            return false;        if (node.val == sum2 && node.left == null && node.right == null)            return true;        return hasPathSum(node.left, sum2 - node.val) || hasPathSum(node.right, sum2 - node.val);    }}